---
title: "SQL for data analysis - essential queries and techniques"
description: "AI model comparison: SQL for data analysis - essential queries and techniques..."
date: 2025-09-30
category: comparison
layout: Clean
tags:
  - Claude
  - DeepSeek
  - Gemini
  - AI Comparison
author: SNEOS Community
head:
  - - meta
    - name: description
      content: "AI model comparison: SQL for data analysis - essential queries and techniques..."
---

<ChatComparison
  title="SQL for data analysis - essential queries and techniques"
  prompt="SQL for data analysis - essential queries and techniques"
  :responses='{
    "Claude": "# SQL for Data Analysis - Essential Queries and Techniques\n\n## Table of Contents\n1. [Basic Analysis Queries](#basic-analysis)\n2. [Aggregation and Grouping](#aggregation-grouping)\n3. [Window Functions](#window-functions)\n4. [Date and Time Analysis](#date-time-analysis)\n5. [Advanced Filtering and Conditions](#advanced-filtering)\n6. [Statistical Functions](#statistical-functions)\n7. [Data Cleaning Techniques](#data-cleaning)\n8. [Performance Optimization](#performance-optimization)\n\n---\n\n## Basic Analysis Queries\n\n### Data Exploration\n\u0060\u0060\u0060sql\n-- Basic table structure and data preview\nSELECT * FROM sales LIMIT 10;\n\n-- Column information and data types\nDESCRIBE sales;\n-- or\nSELECT column_name, data_type, is_nullable \nFROM information_schema.columns \nWHERE table_name = \u0027sales\u0027;\n\n-- Count total records\nSELECT COUNT(*) as total_records FROM sales;\n\n-- Check for duplicates\nSELECT customer_id, product_id, COUNT(*) as duplicate_count\nFROM sales \nGROUP BY customer_id, product_id \nHAVING COUNT(*) \u003E 1;\n\u0060\u0060\u0060\n\n### Basic Statistics\n\u0060\u0060\u0060sql\n-- Summary statistics for numeric columns\nSELECT \n    COUNT(amount) as count,\n    MIN(amount) as min_amount,\n    MAX(amount) as max_amount,\n    AVG(amount) as avg_amount,\n    STDDEV(amount) as std_dev,\n    SUM(amount) as total_amount\nFROM sales;\n\n-- Distinct value counts\nSELECT \n    COUNT(DISTINCT customer_id) as unique_customers,\n    COUNT(DISTINCT product_id) as unique_products,\n    COUNT(DISTINCT category) as unique_categories\nFROM sales;\n\u0060\u0060\u0060\n\n---\n\n## Aggregation and Grouping\n\n### GROUP BY with Multiple Dimensions\n\u0060\u0060\u0060sql\n-- Sales by category and month\nSELECT \n    category,\n    DATE_FORMAT(sale_date, \u0027%Y-%m\u0027) as month,\n    COUNT(*) as transaction_count,\n    SUM(amount) as total_sales,\n    AVG(amount) as avg_transaction_value\nFROM sales \nGROUP BY category, DATE_FORMAT(sale_date, \u0027%Y-%m\u0027)\nORDER BY month, total_sales DESC;\n\n-- Customer segmentation analysis\nSELECT \n    customer_segment,\n    COUNT(DISTINCT customer_id) as customer_count,\n    SUM(amount) as total_revenue,\n    AVG(amount) as avg_order_value,\n    COUNT(*) as total_orders,\n    SUM(amount) / COUNT(DISTINCT customer_id) as revenue_per_customer\nFROM sales s\nJOIN customers c ON s.customer_id = c.customer_id\nGROUP BY customer_segment;\n\u0060\u0060\u0060\n\n### HAVING Clause for Filtered Aggregations\n\u0060\u0060\u0060sql\n-- High-value customers (total purchases \u003E $1000)\nSELECT \n    customer_id,\n    COUNT(*) as order_count,\n    SUM(amount) as total_spent,\n    AVG(amount) as avg_order_value\nFROM sales \nGROUP BY customer_id \nHAVING SUM(amount) \u003E 1000\nORDER BY total_spent DESC;\n\n-- Products with consistent high performance\nSELECT \n    product_id,\n    COUNT(*) as sales_count,\n    AVG(amount) as avg_price\nFROM sales \nGROUP BY product_id \nHAVING COUNT(*) \u003E 10 AND AVG(amount) \u003E 50;\n\u0060\u0060\u0060\n\n---\n\n## Window Functions\n\n### Ranking and Row Numbers\n\u0060\u0060\u0060sql\n-- Top 3 products by sales in each category\nSELECT \n    category,\n    product_id,\n    total_sales,\n    RANK() OVER (PARTITION BY category ORDER BY total_sales DESC) as rank_in_category\nFROM (\n    SELECT \n        category,\n        product_id,\n        SUM(amount) as total_sales\n    FROM sales \n    GROUP BY category, product_id\n) ranked\nWHERE rank_in_category \u003C= 3;\n\n-- Running totals and percentiles\nSELECT \n    sale_date,\n    amount,\n    SUM(amount) OVER (ORDER BY sale_date) as running_total,\n    ROW_NUMBER() OVER (ORDER BY amount DESC) as sales_rank,\n    ",
    "DeepSeek": "Of course! SQL is the fundamental language for working with relational databases, and mastering it is crucial for any data analyst. This guide will walk you through essential queries and techniques, from the absolute basics to more advanced analytical functions.\n\nWe\u0027ll use a sample database for an e-commerce company with the following tables:\n\n*   **\u0060customers\u0060**: \u0060customer_id\u0060, \u0060first_name\u0060, \u0060last_name\u0060, \u0060city\u0060, \u0060signup_date\u0060\n*   **\u0060products\u0060**: \u0060product_id\u0060, \u0060product_name\u0060, \u0060category\u0060, \u0060price\u0060\n*   **\u0060orders\u0060**: \u0060order_id\u0060, \u0060customer_id\u0060, \u0060order_date\u0060\n*   **\u0060order_items\u0060**: \u0060order_item_id\u0060, \u0060order_id\u0060, \u0060product_id\u0060, \u0060quantity\u0060\n\n---\n\n### 1. The Absolute Fundamentals (The \u0022Must-Knows\u0022)\n\nThese are the building blocks of almost every query you\u0027ll write.\n\n#### a) SELECT \u0026 FROM\nRetrieves data from a table.\n\u0060\u0060\u0060sql\nSELECT * FROM customers; -- Gets all columns\nSELECT first_name, last_name FROM customers; -- Gets specific columns\n\u0060\u0060\u0060\n\n#### b) WHERE\nFilters rows based on a condition.\n\u0060\u0060\u0060sql\nSELECT * FROM products WHERE category = \u0027Electronics\u0027;\nSELECT * FROM orders WHERE order_date \u003E= \u00272023-10-01\u0027;\n-- Use AND, OR for multiple conditions\nSELECT * FROM products WHERE category = \u0027Electronics\u0027 AND price \u003E 500;\n\u0060\u0060\u0060\n\n#### c) Aggregate Functions \u0026 GROUP BY\nSummarizes data. Common functions: \u0060COUNT()\u0060, \u0060SUM()\u0060, \u0060AVG()\u0060, \u0060MIN()\u0060, \u0060MAX()\u0060.\n\u0060\u0060\u0060sql\n-- How many customers do we have?\nSELECT COUNT(*) FROM customers;\n\n-- What\u0027s the total revenue from the \u0027order_items\u0027 table?\nSELECT SUM(quantity * price) AS total_revenue\nFROM order_items oi\nJOIN products p ON oi.product_id = p.product_id;\n\n-- What is the average price of products in each category?\nSELECT category, AVG(price) AS average_price\nFROM products\nGROUP BY category;\n\u0060\u0060\u0060\n**Crucial Rule:** When using \u0060GROUP BY\u0060, all columns in the \u0060SELECT\u0060 clause must either be in the \u0060GROUP BY\u0060 clause or be an aggregate function.\n\n#### d) HAVING\nFilters groups created by \u0060GROUP BY\u0060. (WHERE filters rows, HAVING filters groups).\n\u0060\u0060\u0060sql\n-- Find categories with an average product price over $100\nSELECT category, AVG(price) AS average_price\nFROM products\nGROUP BY category\nHAVING AVG(price) \u003E 100;\n\u0060\u0060\u0060\n\n#### e) ORDER BY\nSorts the result set.\n\u0060\u0060\u0060sql\n-- Show products, sorted by price (highest first)\nSELECT product_name, price\nFROM products\nORDER BY price DESC;\n\n-- Show top 10 most recent orders\nSELECT * FROM orders\nORDER BY order_date DESC\nLIMIT 10; -- (LIMIT is used in MySQL, PostgreSQL; use TOP in SQL Server, FETCH FIRST in Oracle)\n\u0060\u0060\u0060\n\n#### f) JOINs\nCombine rows from two or more tables based on a related column. This is the heart of relational data analysis.\n\n*   **INNER JOIN**: Returns records that have matching values in both tables.\n    \u0060\u0060\u0060sql\n    -- Get all orders with customer information\n    SELECT o.order_id, o.order_date, c.first_name, c.last_name\n    FROM orders o\n    INNER JOIN customers c ON o.customer_id = c.customer_id;\n    \u0060\u0060\u0060\n*   **LEFT JOIN**: Returns all records from the left table, and the matched records from the right table. Results from the right with no match are \u0060NULL\u0060.\n    \u0060\u0060\u0060sql\n    -- Get all customers and their orders (even if they haven\u0027t placed any)\n    SELECT c.first_name, c.last_name, o.order_id\n    FROM customers c\n    LEFT JOIN orders o ON c.customer_id = o.customer_id;\n    \u0060\u0060\u0060\n\n---\n\n### 2. Essential Techniques for Analysis\n\n#### a) Using CASE for Conditional Logic\nThe \u0060CASE\u0060 statement is the SQL equivalent of an IF-THEN-ELSE statement. It\u0027s incredibly powerful for creating calculated columns.\n\u0060\u0060\u0060sql\n-- Categorize customers based on their signup date\nSELECT first_name, last_name, signup_date,\n    CASE\n        WHEN signup_date \u003E \u00272023-09-01\u0027 THEN \u0027New\u0027\n        WHEN signup_date \u003E \u00272023-01-01\u0027 THEN \u0027Active\u0027\n        ELSE \u0027Legacy\u0027\n    END AS customer_segment\nFROM customers;\n\n-- Create a flag for high-value products\nSELECT product_name, price,\n    CASE\n        WHEN price \u003E 1000 THEN \u0027Premium\u0027\n        WHEN price \u003E 100 THEN \u0027Mid-Range\u0027\n        ELSE \u0027Budget\u0027\n    END AS price_tier\nFROM products;\n\u0060\u0060\u0060\n\n#### b) Date and Time Functions\nAnalyzing trends over time is a core analytical task.\n\u0060\u0060\u0060sql\n-- Extract the year and month from a date (PostgreSQL syntax)\nSELECT order_id, order_date,\n       EXTRACT(YEAR FROM order_date) AS order_year,\n       EXTRACT(MONTH FROM order_date) AS order_month\nFROM orders;\n\n-- Calculate the number of days between two dates (e.g., signup and first order)\nSELECT c.customer_id,\n       MIN(o.order_date) - c.signup_date AS days_to_first_order\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.signup_date;\n\u0060\u0060\u0060\n*Note: Date functions vary significantly by database (MySQL: \u0060YEAR()\u0060, \u0060MONTH()\u0060; SQL Server: \u0060DATEPART()\u0060). Always check your database\u0027s documentation.*\n\n---\n\n### 3. Advanced Analytical Queries (Window Functions)\n\nWindow functions perform a calculation across a set of table rows that are somehow related to the current row. They are a game-changer for data analysis.\n\n#### a) ROW_NUMBER(), RANK(), DENSE_RANK()\nAssign a unique rank or row number to rows within a partition.\n\u0060\u0060\u0060sql\n-- Rank products by price within their category\nSELECT product_name, category, price,\n       ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS row_num,\n       RANK() OVER (PARTITION BY category ORDER BY price DESC) AS rank,\n       DENSE_RANK() OVER (PARTITION BY category ORDER BY price DESC) AS dense_rank\nFROM products;\n\u0060\u0060\u0060\n*\u0060ROW_NUMBER()\u0060 gives unique numbers. \u0060RANK()\u0060 leaves gaps in the sequence for ties. \u0060DENSE_RANK()\u0060 does not leave gaps.*\n\n#### b) Running Totals with SUM()\n\u0060\u0060\u0060sql\n-- Calculate the running total of daily revenue\nSELECT order_date,\n       SUM(quantity * price) AS daily_revenue,\n       SUM(SUM(quantity * price)) OVER (ORDER BY order_date) AS running_total\nFROM orders o\nJOIN order_items oi ON o.order_id = oi.order_id\nJOIN products p ON oi.product_id = p.product_id\nGROUP BY order_date\nORDER BY order_date;\n\u0060\u0060\u0060\n\n#### c) LAG() and LEAD()\nAccess data from a previous or subsequent row in the same result set. Perfect for calculating month-over-month growth.\n\u0060\u0060\u0060sql\n-- Compare each month\u0027s revenue with the previous month\u0027s\nWITH monthly_revenue AS (\n  SELECT\n    DATE_TRUNC(\u0027month\u0027, order_date) AS revenue_month,\n    SUM(quantity * price) AS monthly_rev\n  FROM orders o\n  JOIN order_items oi ON o.order_id = oi.order_id\n  JOIN products p ON oi.product_id = p.product_id\n  GROUP BY DATE_TRUNC(\u0027month\u0027, order_date)\n)\nSELECT revenue_month,\n       monthly_rev,\n       LAG(monthly_rev) OVER (ORDER BY revenue_month) AS previous_month_rev,\n       (monthly_rev - LAG(monthly_rev) OVER (ORDER BY revenue_month)) / LAG(monthly_rev) OVER (ORDER BY revenue_month) * 100 AS growth_percentage\nFROM monthly_revenue\nORDER BY revenue_month;\n\u0060\u0060\u0060\n\n---\n\n### 4. Structuring Complex Queries\n\n#### a) Common Table Expressions (CTEs)\nCTEs create temporary, named result sets that you can reference within your main query. They make complex queries much more readable and modular.\n\u0060\u0060\u0060sql\n-- Find the top-spending customer in each city\nWITH CustomerSpending AS (\n    SELECT\n        c.customer_id,\n        c.first_name,\n        c.last_name,\n        c.city,\n        SUM(oi.quantity * p.price) AS total_spent\n    FROM customers c\n    JOIN orders o ON c.customer_id = o.customer_id\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    GROUP BY c.customer_id, c.first_name, c.last_name, c.city\n),\nRankedSpending AS (\n    SELECT *,\n           RANK() OVER (PARTITION BY city ORDER BY total_spent DESC) AS spending_rank\n    FROM CustomerSpending\n)\nSELECT * FROM RankedSpending\nWHERE spending_rank = 1;\n\u0060\u0060\u0060\n\n### Best Practices for Data Analysts\n\n1.  **Start with a Plan:** Write down the question you\u0027re trying to answer in plain English before writing any code.\n2.  **Build Incrementally:** Start with a simple \u0060SELECT * FROM table\u0060 to see your data. Then add \u0060JOINs\u0060, then \u0060WHERE\u0060 filters, then \u0060GROUP BY\u0060, etc. This makes debugging much easier.\n3.  **Use Aliases:** Always use clear table aliases (like \u0060c\u0060 for \u0060customers\u0060) to make your queries cleaner.\n4.  **Format Your",
    "Gemini": "Okay, let\u0027s break down essential SQL queries and techniques for data analysis.  I\u0027ll cover fundamental concepts, common functions, and then tie it all together with practical examples.\n\n**I. Core SQL Concepts for Data Analysis**\n\n*   **SELECT:**  The foundation. Used to choose which columns you want to retrieve.\n*   **FROM:**  Specifies the table (or tables) you\u0027re querying.\n*   **WHERE:**  Filters rows based on conditions.  This is crucial for focusing your analysis.\n*   **GROUP BY:**  Groups rows that have the same values in one or more columns.  Essential for aggregations.\n*   **HAVING:** Filters *groups* after they\u0027ve been formed by \u0060GROUP BY\u0060.  It\u0027s like \u0060WHERE\u0060 for groups.\n*   **ORDER BY:**  Sorts the result set.  Useful for ranking, identifying top/bottom performers, and clearer presentation.\n*   **JOIN:**  Combines data from multiple tables based on related columns.  Absolutely vital when your data is spread across multiple tables.\n*   **Subqueries:**  A query nested inside another query.  Allows you to perform complex filtering or calculations.\n*   **Common Table Expressions (CTEs):**  A named temporary result set that can be referenced within a larger query.  Improves readability and modularity.\n*   **Window Functions:** Perform calculations across a set of table rows that are related to the current row.  Very powerful for ranking, moving averages, and other complex calculations.\n\n**II.  Fundamental Queries \u0026 Techniques**\n\n1.  **Basic Selection and Filtering:**\n\n    \u0060\u0060\u0060sql\n    -- Select all columns from the \u0027customers\u0027 table\n    SELECT *\n    FROM customers;\n\n    -- Select specific columns (customer_id, first_name, last_name)\n    SELECT customer_id, first_name, last_name\n    FROM customers;\n\n    -- Filter customers based on their city\n    SELECT *\n    FROM customers\n    WHERE city = \u0027New York\u0027;\n\n    -- Filter customers based on a range of ages\n    SELECT *\n    FROM customers\n    WHERE age BETWEEN 25 AND 35;\n\n    -- Filter customers based on a list of cities\n    SELECT *\n    FROM customers\n    WHERE city IN (\u0027London\u0027, \u0027Paris\u0027, \u0027Tokyo\u0027);\n\n    -- Filter customers where the last name starts with \u0027S\u0027\n    SELECT *\n    FROM customers\n    WHERE last_name LIKE \u0027S%\u0027;  -- % is a wildcard for zero or more characters\n\n    -- Filter customers where the last name contains \u0027son\u0027\n    SELECT *\n    FROM customers\n    WHERE last_name LIKE \u0027%son%\u0027;\n\n    -- Find customers where the email is null\n    SELECT *\n    FROM customers\n    WHERE email IS NULL;\n\n    -- Find customers where the email is NOT null\n    SELECT *\n    FROM customers\n    WHERE email IS NOT NULL;\n    \u0060\u0060\u0060\n\n2.  **Aggregation and Grouping:**\n\n    \u0060\u0060\u0060sql\n    -- Count the total number of customers\n    SELECT COUNT(*) AS total_customers\n    FROM customers;\n\n    -- Calculate the average age of customers\n    SELECT AVG(age) AS average_age\n    FROM customers;\n\n    -- Find the maximum and minimum ages\n    SELECT MAX(age) AS max_age, MIN(age) AS min_age\n    FROM customers;\n\n    -- Sum the total order amounts\n    SELECT SUM(order_amount) AS total_order_amount\n    FROM orders;\n\n    -- Group customers by city and count the number of customers in each city\n    SELECT city, COUNT(*) AS customer_count\n    FROM customers\n    GROUP BY city;\n\n    -- Group by city and find the average age in each city\n    SELECT city, AVG(age) AS average_age\n    FROM customers\n    GROUP BY city;\n\n    -- Group by city and find the total order amount from customers in each city\n    SELECT c.city, SUM(o.order_amount) AS total_order_amount\n    FROM customers c\n    JOIN orders o ON c.customer_id = o.customer_id\n    GROUP BY c.city;\n\n    -- Group by city and count customers, but only include cities with more than 5 customers\n    SELECT city, COUNT(*) AS customer_count\n    FROM customers\n    GROUP BY city\n    HAVING COUNT(*) \u003E 5;  -- HAVING filters the *groups*\n    \u0060\u0060\u0060\n\n3.  **Sorting:**\n\n    \u0060\u0060\u0060sql\n    -- Sort customers by last name in ascending order (default)\n    SELECT *\n    FROM customers\n    ORDER BY last_name;\n\n    -- Sort customers by age in descending order\n    SELECT *\n    FROM customers\n    ORDER BY age DESC;\n\n    -- Sort by city, then by last name within each city\n    SELECT *\n    FROM customers\n    ORDER BY city, last_name;\n    \u0060\u0060\u0060\n\n4.  **Joining Tables:**\n\n    \u0060\u0060\u0060sql\n    -- Inner Join:  Get order information along with customer details\n    SELECT o.order_id, c.first_name, c.last_name, o.order_date, o.order_amount\n    FROM orders o\n    INNER JOIN customers c ON o.customer_id = c.customer_id;\n\n    -- Left Join: Get all customers and their order information (if any)\n    SELECT c.first_name, c.last_name, o.order_id, o.order_date, o.order_amount\n    FROM customers c\n    LEFT JOIN orders o ON c.customer_id = o.customer_id;\n\n    -- Right Join: Get all orders and the customer information (if any)\n    SELECT c.first_name, c.last_name, o.order_id, o.order_date, o.order_amount\n    FROM customers c\n    RIGHT JOIN orders o ON c.customer_id = o.customer_id;\n\n    -- Full Outer Join: Get all customers and all orders, regardless of matches\n    -- Note:  Not supported directly in MySQL.  Requires a workaround using UNION.\n    SELECT c.first_name, c.last_name, o.order_id, o.order_date, o.order_amount\n    FROM customers c\n    LEFT JOIN orders o ON c.customer_id = o.customer_id\n    UNION ALL\n    SELECT c.first_name, c.last_name, o.order_id, o.order_date, o.order_amount\n    FROM customers c\n    RIGHT JOIN orders o ON c.customer_id = o.customer_id\n    WHERE c.customer_id IS NULL;  -- Avoid duplicate rows from the LEFT JOIN part\n    \u0060\u0060\u0060\n\n5.  **Subqueries:**\n\n    \u0060\u0060\u0060sql\n    -- Find customers who placed orders with an amount greater than the average order amount\n    SELECT c.first_name, c.last_name\n    FROM customers c\n    WHERE c.customer_id IN (\n        SELECT o.customer_id\n        FROM orders o\n        WHERE o.order_amount \u003E (SELECT AVG(order_amount) FROM orders)\n    );\n\n    -- Get the customer who placed the largest order\n    SELECT c.first_name, c.last_name\n    FROM customers c\n    WHERE c.customer_id = (\n        SELECT o.customer_id\n        FROM orders o\n        ORDER BY o.order_amount DESC\n        LIMIT 1\n    );\n    \u0060\u0060\u0060\n\n6.  **Common Table Expressions (CTEs):**\n\n    \u0060\u0060\u0060sql\n    -- Calculate the average order amount per customer\n    WITH CustomerOrderAverages AS (\n        SELECT\n            customer_id,\n            AVG(order_amount) AS average_order_amount\n        FROM\n            orders\n        GROUP BY\n            customer_id\n    )\n    SELECT\n        c.first_name,\n        c.last_name,\n        coa.average_order_amount\n    FROM\n        customers c\n    JOIN\n        CustomerOrderAverages coa ON c.customer_id = coa.customer_id;\n\n    -- Example with multiple CTEs to calculate customer lifetime value\n    WITH\n    FirstOrders AS (\n        SELECT\n            customer_id,\n            MIN(order_date) AS first_order_date\n        FROM\n            orders\n        GROUP BY\n            customer_id\n    ),\n    LastOrders AS (\n        SELECT\n            customer_id,\n            MAX(order_date) AS last_order_date\n        FROM\n            orders\n        GROUP BY\n            customer_id\n    ),\n    CustomerLifetimes AS (\n        SELECT\n            fo.customer_id,\n            JULIANDAY(lo.last_order_date) - JULIANDAY(fo.first_order_date) AS lifetime_days\n        FROM\n            FirstOrders fo\n        JOIN\n            LastOrders lo ON fo.customer_id = lo.customer_id\n    )\n    SELECT\n        c.first_name,\n        c.last_name,\n        cl.lifetime_days\n    FROM\n        customers c\n    JOIN\n        CustomerLifetimes cl ON c.customer_id = cl.customer_id;\n    \u0060\u0060\u0060\n\n7.  **Window Functions:**\n\n    \u0060\u0060\u0060sql\n    -- Rank customers based on their total order amount\n    SELECT\n        c.first_name,\n        c.last_name,\n        SUM(o.order_amount) AS total_order_amount,\n        RANK() OVER (ORDER BY SUM(o.order_amount) DESC) AS order_rank\n    FROM\n        customers c\n    JOIN\n        orders o ON c.customer_id = o.customer_id\n    GROUP BY\n        c.customer_id, c.first_name, c.last_name;\n\n    -- Calculate a moving average of order amounts over the past 3 orders for each customer\n    SELECT\n        o.order_id,\n        o.customer_id,\n        o.order_date,\n        o.order_amount,\n        AVG(o.order_amount) OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_average\n    FROM\n        orders o;\n\n    -- Get the previous order amount for each customer\n    SELECT\n        o.order_id,\n        o.customer_id,\n        o.order_date,\n        o.order_amount,\n        LAG(o.order_amount, 1, 0) OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC) AS previous_order_amount\n    FROM\n        orders o;\n    \u0060\u0060\u0060\n\n**III. Useful SQL Functions for Data Analysis**\n\n*   **String Functions:**\n    *   \u0060UPPER(string)\u0060: Converts a string to uppercase.\n    *   \u0060LOWER(string)\u0060: Converts a string to lowercase.\n    *   \u0060SUBSTRING(string, start, length)\u0060: Extracts a substring from a string.\n    *   \u0060LENGTH(string)\u0060: Returns the length of a string.\n    *   \u0060TRIM(string)\u0060: Removes leading and trailing whitespace from a string.\n    *   \u0060REPLACE(string, old_substring, new_substring)\u0060: Replaces occurrences of a substring within a string.\n    *   \u0060CONCAT(string1, string2, ...)\u0060: Concatenates strings.\n\n*   **Numeric Functions:**\n    *   \u0060ABS(number)\u0060: Returns the absolute value of a number.\n    *   \u0060ROUND(number, decimals)\u0060: Rounds a number to a specified number of decimal places.\n    *   \u0060FLOOR(number)\u0060: Returns the largest integer less than or equal to a number.\n    *   \u0060CEILING(number)\u0060: Returns the smallest integer greater than or equal to a number.\n    *   \u0060MOD(number1, number2)\u0060: Returns the remainder of a division.\n\n*   **Date/Time Functions:**\n    *   \u0060NOW()\u0060 (or \u0060CURRENT_TIMESTAMP\u0060): Returns the current date and time.\n    *   \u0060CURDATE()\u0060 (or \u0060CURRENT_DATE\u0060): Returns the current date.\n    *   \u0060CURTIME()\u0060 (or \u0060CURRENT_TIME\u0060): Returns the current time.\n    *   \u0060DATE(datetime)\u0060: Extracts the date part from a datetime value.\n    *   \u0060TIME(datetime)\u0060: Extracts the time part from a datetime value.\n    *   \u0060YEAR(date)\u0060, \u0060MONTH(date)\u0060, \u0060DAY(date)\u0060, \u0060HOUR(datetime)\u0060, \u0060MINUTE(datetime)\u0060, \u0060SECOND(datetime)\u0060: Extract specific date/time parts.\n    *   \u0060DATE_ADD(date, INTERVAL value unit)\u0060: Adds an interval to a date.\n    *   \u0060DATE_SUB(date, INTERVAL value unit)\u0060: Subtracts an interval from a date.\n    *   \u0060DATEDIFF(date1, date2)\u0060: Returns the number of days between two dates.\n\n*   **Aggregate Functions:**\n    *   \u0060COUNT(*)\u0060: Counts the number of rows.\n    *   \u0060COUNT(column)\u0060: Counts the number of non-NULL values in a column.\n    *   \u0060SUM(column)\u0060: Sums the values in a column.\n    *   \u0060AVG(column)\u0060: Calculates the average of the values in a column.\n    *   \u0060MIN(column)\u0060: Finds the minimum value in a column.\n    *   \u0060MAX(column)\u0060: Finds the maximum value in a column.\n    *   \u0060STDDEV(column)\u0060:  Calculates the standard deviation of values in a column.\n    *   \u0060VARIANCE(column)\u0060:  Calculates the variance of values in a column.\n\n*   **Control Flow Functions:**\n    *   \u0060CASE WHEN condition THEN result ELSE result END\u0060:  Conditional logic.\n    *   \u0060IF(condition, value_if_true, value_if_false)\u0060:  A shorthand for \u0060CASE WHEN\u0060.\n    *   \u0060COALESCE(value1, value2, ...)\u0060: Returns the first non-NULL value in a list.\n\n**IV.  Practical Examples \u0026 Scenarios**\n\nLet\u0027s illustrate with a scenario:\n\n**Scenario:** You work for an e-commerce company and have these tables:\n\n*   \u0060Customers\u0060: \u0060customer_id\u0060, \u0060first_name\u0060, \u0060last_name\u0060, \u0060email\u0060, \u0060city\u0060, \u0060signup_date\u0060\n*   \u0060Orders\u0060: \u0060order_id\u0060, \u0060customer_id\u0060, \u0060order_date\u0060, \u0060total_amount\u0060\n*   \u0060Products\u0060: \u0060product_id\u0060, \u0060product_name\u0060, \u0060category\u0060, \u0060price\u0060\n*   \u0060Order_Items\u0060: \u0060order_id\u0060, \u0060product_id\u0060, \u0060quantity\u0060\n\n**Example Queries:**\n\n1.  **Top 5 customers by total spending:**\n\n    \u0060\u0060\u0060sql\n    SELECT\n        c.first_name,\n        c.last_name,\n        SUM(o.total_amount) AS total_spent\n    FROM\n        Customers c\n    JOIN\n        Orders o ON c.customer_id = o.customer_id\n    GROUP BY\n        c.customer_id, c.first_name, c.last_name\n    ORDER BY\n        total_spent DESC\n    LIMIT 5;\n    \u0060\u0060\u0060\n\n2.  **Average order value per month:**\n\n    \u0060\u0060\u0060sql\n    SELECT\n        YEAR(order_date) AS order_year,\n        MONTH(order_date) AS order_month,\n        AVG(total_amount) AS average_order_value\n    FROM\n        Orders\n    GROUP BY\n        YEAR(order_date), MONTH(order_date)\n    ORDER BY\n        order_year, order_month;\n    \u0060\u0060\u0060\n\n3.  **Most popular product category:**\n\n    \u0060\u0060\u0060sql\n    SELECT\n        p.category,\n        SUM(oi.quantity) AS total_quantity_sold\n    FROM\n        Products p\n    JOIN\n        Order_Items oi ON p.product_id = oi.product_id\n    GROUP BY\n        p.category\n    ORDER BY\n        total_quantity_sold DESC\n    LIMIT 1;\n    \u0060\u0060\u0060\n\n4.  **Customers who signed up in the last 30 days and placed an order:**\n\n    \u0060\u0060\u0060sql\n    SELECT\n        c.first_name,\n        c.last_name\n    FROM\n        Customers c\n    WHERE\n        c.signup_date \u003E= DATE(\u0027now\u0027, \u0027-30 days\u0027)\n        AND c.customer_id IN (SELECT customer_id FROM Orders);\n    \u0060\u0060\u0060\n\n5.  **Customer retention rate (percentage of customers who made a purchase in both the current month and the previous month):**\n\n    \u0060\u0060\u0060sql\n    WITH\n    MonthlyCustomers AS (\n        SELECT\n            YEAR(order_date) AS order_year,\n            MONTH(order_date) AS order_month,\n            COUNT(DISTINCT customer_id) AS num_customers\n        FROM\n            Orders\n        GROUP BY\n            YEAR(order_date), MONTH(order_date)\n    ),\n    LaggedMonthlyCustomers AS (\n        SELECT\n            order_year,\n            order_month,\n            num_customers,\n            LAG(num_customers, 1, 0) OVER (ORDER BY order_year, order_month) AS previous_month_customers\n        FROM\n            MonthlyCustomers\n    ),\n    RetainedCustomers AS (\n        SELECT\n            YEAR(o1.order_date) AS order_year,\n            MONTH(o1.order_date) AS order_month,\n            COUNT(DISTINCT o1.customer_id) AS num_retained_customers\n        FROM\n            Orders o1\n        JOIN\n            Orders o2 ON o1.customer_id = o2.customer_id\n            AND YEAR(o1.order_date) = YEAR(DATE(o2.order_date, \u0027\u002B1 month\u0027))\n            AND MONTH(o1.order_date) = MONTH(DATE(o2.order_date, \u0027\u002B1 month\u0027))\n        GROUP BY\n            YEAR(o1.order_date), MONTH(o1.order_date)\n    )\n    SELECT\n        lmc.order_year,\n        lmc.order_month,\n        lmc.num_customers,\n        lmc.previous_month_customers,\n        rc.num_retained_customers,\n        CAST(rc.num_retained_customers AS REAL) / lmc.previous_month_customers AS retention_rate\n    FROM\n        LaggedMonthlyCustomers lmc\n    JOIN\n        RetainedCustomers rc ON lmc.order_year = rc.order_year AND lmc.order_month = rc.order_month;\n    \u0060\u0060\u0060\n\n**Key Considerations for Data Analysis in SQL:**\n\n*   **Data Types:** Be aware of your data types (integer, float, date, string) and use the appropriate functions.  Incorrect data types can lead to unexpected results or errors.\n*   **NULL Values:** Understand how \u0060NULL\u0060 values are handled in SQL.  They often require special handling in comparisons and calculations (e.g., using \u0060IS NULL\u0060, \u0060IS NOT NULL\u0060, \u0060COALESCE\u0060).\n*   **Performance:**  For large datasets, performance matters.\n    *   Use indexes on columns frequently used in \u0060WHERE\u0060 clauses and \u0060JOIN\u0060 conditions.\n    *   Avoid using \u0060SELECT *\u0060 when you only need a few columns.\n    *   Be mindful of complex joins, as they can be expensive.\n    *   Profile your queries to identify bottlenecks and optimize them.\n*   **Database-Specific Syntax:**  While the core SQL standards are widely followed, there can be slight variations in syntax and function names between different database systems (MySQL, PostgreSQL, SQL Server, Oracle, etc.).  Consult your database\u0027s documentation.\n*   **Data Cleaning:**  Real-world data is often messy. You might need to use string functions to clean and standardize data before analysis.\n*   **Business Context:**  Always keep the business context in mind.  Understand what questions you\u0027re trying to answer and what insights you\u0027re looking for.\n\n**In Summary:**\n\nSQL is an essential skill for data analysis.  By mastering the core concepts, functions, and techniques covered here, you\u0027ll be well-equipped to extract valuable insights from your data. Remember to practice, experiment, and always consult your database documentation for specific details. Good luck!\n"
  }'
  published-date="22:46"
/>

## Analysis

This comparison demonstrates the different approaches each AI model takes when responding to the same prompt. Here are the key differences observed:

### Response Characteristics

**Claude**: Provides a detailed response with 11 sentences. 

**DeepSeek**: Provides a direct response with 94 sentences. 

**Gemini**: Provides a direct response with 227 sentences. 

## Key Takeaways

- Each model brings unique strengths to this type of query
- Response styles vary significantly between models
- Consider your specific use case when choosing between these models

## Try This Comparison Yourself

Want to test these models with your own prompts? Visit [SNEOS.com](https://sneos.com) to compare AI responses side-by-side in real-time.

---

*This comparison was generated using the [SNEOS AI Comparison Tool](https://sneos.com)*
*Published: September 30, 2025 | Models: Claude, DeepSeek, Gemini*
