import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const AI_LIBRARY_DIR = path.join(__dirname, '../docs/ai-library');
const INDEX_FILE = path.join(AI_LIBRARY_DIR, 'README.md');

// Recursively scan all directories for markdown files
function scanDirectory(dir, basePath = '') {
  const files = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = basePath ? path.join(basePath, entry.name) : entry.name;

    if (entry.isDirectory()) {
      // Recursively scan subdirectories
      files.push(...scanDirectory(fullPath, relativePath));
    } else if (entry.name.endsWith('.md') && entry.name !== 'index.md' && entry.name !== '00-index.md' && entry.name !== 'README.md') {
      try {
        const content = fs.readFileSync(fullPath, 'utf-8');
        const { data } = matter(content);

        const title = data.title || entry.name.replace('.md', '');
        const description = data.description || '';

        // Extract the top-level category (first directory in path)
        const categoryFolder = relativePath.split(path.sep)[0];

        files.push({
          categoryFolder,
          relativePath: relativePath.replace('.md', ''),
          filename: entry.name.replace('.md', ''),
          title,
          description,
          tags: data.tags || [],
          date: data.date
        });
      } catch (error) {
        console.error(`Error reading ${fullPath}:`, error.message);
      }
    }
  }

  return files;
}

const files = scanDirectory(AI_LIBRARY_DIR);

// Group by category folder
const categorized = {};

// Generate human-readable category names from folder names
function formatCategoryName(folderName) {
  return folderName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

files.forEach(file => {
  const categoryName = formatCategoryName(file.categoryFolder);

  if (!categorized[categoryName]) {
    categorized[categoryName] = [];
  }
  categorized[categoryName].push(file);
});

// Generate markdown content
const categoryCount = Object.keys(categorized).length;
let content = `---
title: "Index"
description: "Comprehensive index of ${files.length} AI comparison posts across ${categoryCount} categories"
date: 2025-09-29
category: comparison
tags:
  - AI Comparison
  - Index
  - Autogenerated
author: SNEOS Community
---

# Index

Welcome to the comprehensive AI comparisons directory. Explore **${files.length} detailed comparisons** across **${categoryCount} categories**, featuring head-to-head analyses of ChatGPT, Claude, DeepSeek, Gemini, Grok, and Mistral.

## Quick Stats

| Metric | Count |
|--------|-------|
| Total Posts | ${files.length} |
| Categories | ${categoryCount} |
| AI Models Compared | 6+ |

## Browse by Category

`;

// Sort categories and add posts
Object.keys(categorized).sort().forEach(category => {
  const posts = categorized[category];
  if (posts.length === 0) return;

  content += `### ${category}\n\n`;
  content += `<span class="category-badge">${posts.length} posts</span>\n\n`;

  posts.forEach(post => {
    const link = `/ai-library/${post.relativePath}.html`;
    content += `**[${post.title}](${link})**\n\n`;
  });

  content += '---\n\n';
});

content += `## About This Index

This directory contains comprehensive AI model comparisons across diverse topics and use cases. Each post features:

- **Head-to-head analysis** of multiple AI models
- **Real-world scenarios** and practical applications
- **Detailed comparisons** of responses and capabilities
- **Updated insights** reflecting 2025 AI capabilities

### Contributing Models

Our comparisons include leading AI models: ChatGPT, Claude, DeepSeek, Gemini, Grok, and Mistral.

---

*Last updated: ${new Date().toISOString().split('T')[0]} | Automatically generated index*
`;

// Write the index file
fs.writeFileSync(INDEX_FILE, content, 'utf-8');
console.log(`âœ… Generated README.md index with ${files.length} posts across ${Object.keys(categorized).length} categories`);